<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vocal Pitch Detector</title>
  <meta name="theme-color" content="#0a84ff" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f5f7fa;
      --bg-alt: #ffffff;
      --bg-elev: #ffffffcc;
      --text: #0f1419;
      --text-dim: #48525c;
      --primary: #0a84ff;
      --primary-glow: #7cc4ff;
      --border: #d8e1ea;
      --border-strong: #b3c2d1;
      --shadow: 0 4px 10px -2px rgba(0,0,0,.08), 0 2px 4px -1px rgba(0,0,0,.06);
      --radius-sm: 6px;
      --radius: 14px;
      --radius-lg: 22px;
      --focus: 0 0 0 3px #0a84ff40;
      --key-white: #ffffff;
      --key-white-edge: #c9d3dd;
      --key-black: #14181d;
      --highlight-white: linear-gradient(160deg,#b7ecff,#79c6ff 60%,#49a4ff);
      --highlight-black: linear-gradient(145deg,#27c3ff,#1787ff 60%,#0068ff);
      --danger: #d93030;
      --warning: #f7b537;
      --success: #12a150;
      --font-stack: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, 'Helvetica Neue', Arial, sans-serif;
      --transition-fast: 140ms cubic-bezier(.4,0,.2,1);
      --transition: 220ms cubic-bezier(.4,0,.2,1);
  /* Piano sizing variables */
  --white-key-width: 80px;
  --piano-key-gap: 2px; /* spacing between white keys */
  /* Piano appearance */
  --white-key-bg: linear-gradient(180deg,var(--key-white) 0%, #e9eef3 96%);
  --white-key-bg-active: var(--highlight-white);
  --black-key-bg: linear-gradient(175deg,#242b32,#0d1114 80%);
  --black-key-bg-active: var(--highlight-black);
  --black-key-border: #0b0f12;
  --white-key-top-highlight: #f8fafc;
    }
    body.dark-mode {
      --bg: #0f1215;
      --bg-alt: #151a20;
      --bg-elev: #1c232bfa;
      --text: #eef2f6;
      --text-dim: #95a2b1;
      --border: #28313b;
      --border-strong: #3a4652;
      --key-white: #f3f6f9;
      --key-white-edge: #5a6673;
      --key-black: #070a0d;
  --white-key-bg: linear-gradient(185deg,#424d58 0%, #313a42 85%);
  --white-key-bg-active: linear-gradient(175deg,#55c8ff,#1a8fff 60%,#0073ff);
  --black-key-bg: linear-gradient(175deg,#2f3942,#12171b 80%);
  --black-key-bg-active: linear-gradient(145deg,#27c3ff,#1787ff 60%,#0068ff);
  --black-key-border: #1c242b;
  --white-key-top-highlight: #5c6670;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: var(--font-stack);
      background: radial-gradient(circle at 30% 20%, #ffffff, var(--bg) 60%) fixed;
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      display: flex;
      flex-direction: column;
    }
    body.dark-mode { background: radial-gradient(circle at 70% 30%, #1e262e, var(--bg) 65%) fixed; }

    header {
      padding: clamp(0.75rem, 1.5vw, 1.1rem) clamp(1rem, 2vw, 2rem);
      display: flex;
      align-items: center;
      justify-content: space-between;
      backdrop-filter: blur(12px) saturate(140%);
      background: linear-gradient(90deg,var(--bg-elev),var(--bg-elev));
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 40;
    }
    h1 {
      margin: 0;
      font-size: clamp(1.2rem, 2.8vw, 1.85rem);
      font-weight: 600;
      letter-spacing: .5px;
      background: linear-gradient(120deg,var(--primary) 30%, var(--primary-glow));
  background-clip: text;
      -webkit-background-clip: text;
      color: transparent;
    }
    #app {
      width: 100%;
      max-width: 1180px;
      margin: 0 auto;
      padding: 1.4rem clamp(.75rem,2vw,1.75rem) 3rem;
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 2.2rem;
    }

    .panel {
      background: var(--bg-alt);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: clamp(1rem,2.8vw,1.85rem);
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }
    .panel:before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(140deg, var(--primary)10%, transparent 45%, transparent 55%, var(--primary-glow) 90%);
      opacity: .07;
      pointer-events: none;
    }

    .display-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit,minmax(180px,1fr));
      gap: 1.25rem;
      align-items: stretch;
    }
    .metric {
      background: linear-gradient(180deg,var(--bg-alt), var(--bg) 120%);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: .9rem 1.1rem 1rem;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: .35rem;
      min-height: 112px;
    }
    .metric h2 {
      font-size: .8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.4px;
      margin: 0;
      color: var(--text-dim);
    }
    .metric .value {
      font-size: clamp(1.4rem,3.8vw,2.8rem);
      font-weight: 600;
      line-height: 1.05;
      letter-spacing: .5px;
      font-variant-numeric: tabular-nums;
      word-break: break-word;
    }
    .metric.small .value { font-size: clamp(1rem,2.5vw,1.45rem); }

    .actions { display:flex; flex-wrap:wrap; gap:.75rem; }
    button, .btn {
      --btn-bg: var(--primary);
      --btn-bg-hover: #006fe6;
      --btn-bg-active: #005bbd;
      --btn-text: #fff;
      font: inherit;
      font-weight: 600;
      padding: .8rem 1.3rem .85rem;
      border-radius: var(--radius-sm);
      background: var(--btn-bg);
      color: var(--btn-text);
      border: 1px solid var(--btn-bg);
      cursor: pointer;
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: .55rem;
      line-height: 1.1;
      letter-spacing: .3px;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
      box-shadow: 0 1px 2px rgba(0,0,0,.15), 0 4px 10px -4px rgba(0,0,0,.25);
      will-change: transform;
      text-decoration: none;
    }
    button:focus-visible { outline: none; box-shadow: var(--focus); }
    button:hover { background: var(--btn-bg-hover); }
    button:active { background: var(--btn-bg-active); transform: translateY(1px); }
    button:disabled { opacity: .55; cursor: not-allowed; filter: grayscale(.3); }
    .btn-secondary { --btn-bg: var(--bg-alt); --btn-bg-hover: #e2e8f0; --btn-bg-active:#d5dee8; --btn-text: var(--text); border-color: var(--border-strong); }
    body.dark-mode .btn-secondary { --btn-bg: #232b33; --btn-bg-hover:#2c3540; --btn-bg-active:#1d252d; }

    /* Piano */
    #piano-wrapper { position: relative; }
    #piano-scroll {
      width: 100%;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding: 1rem .4rem 1.2rem; /* tighter bottom since piano has own radius */
      margin: 0 auto;
      border-radius: var(--radius);
      background: linear-gradient(180deg,var(--bg-alt), var(--bg));
      border: 1px solid var(--border);
      box-shadow: inset 0 0 0 1px var(--border), var(--shadow);
    }
    #piano-scroll::-webkit-scrollbar { height: 14px; }
    #piano-scroll::-webkit-scrollbar-track { background: transparent; }
    #piano-scroll::-webkit-scrollbar-thumb { background: #b8c6d4; border-radius: 100px; border: 3px solid var(--bg-alt); }
    body.dark-mode #piano-scroll::-webkit-scrollbar-thumb { background:#465563; border-color: #1d252d; }

    #piano-grid {
      position: relative;
  /* width now set dynamically in JS based on key count */
      height: clamp(180px, 30vh, 240px);
  margin: 0; /* keep edges aligned with piano */
      border: 1px solid var(--border);
      border-radius: 14px 14px 0 0;
      background: linear-gradient(180deg,var(--bg-alt),var(--bg) 140%);
      overflow: hidden;
    }
    #piano {
      position: relative;
      display: flex;
      flex-direction: row;
  gap: var(--piano-key-gap);
      height: clamp(180px, 30vh, 240px);
      min-height: 140px;
  /* width set dynamically; remove horizontal padding to align with grid */
  padding: 0 0 6px;
      user-select: none;
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 18px 18px;
      background: linear-gradient(180deg,var(--bg-alt), var(--bg));
    }
    /* Canvas overlay for recent pitch history now inside grid */
    #piano-timeline-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 5; /* behind grid lines */
      pointer-events: none;
    }
    .white-key {
      position: relative;
      display: inline-flex;
      justify-content: center;
      align-items: flex-end;
  width: var(--white-key-width);
  flex: 0 0 var(--white-key-width);
      height: 100%;
  background: var(--white-key-bg);
  border: 1px solid var(--key-white-edge);
  border-top: 1px solid var(--white-key-top-highlight);
      border-radius: 0 0 18px 18px;
  margin: 0; /* spacing handled by flex gap */
      font-size: .85rem;
      font-weight: 500;
      color: var(--text-dim);
      letter-spacing: .5px;
      cursor: pointer;
      transition: background var(--transition), color var(--transition), box-shadow var(--transition), transform var(--transition-fast);
      box-shadow: inset 0 0 0 1px #fff, 0 4px 8px -3px rgba(0,0,0,.25);
    }
    .white-key span { position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); pointer-events: none; }
    .white-key:active { transform: translateY(2px); }
    .white-key.active {
      background: var(--white-key-bg-active);
      color: #06314d;
      box-shadow: 0 0 0 1px #117ebf, 0 4px 14px -3px rgba(0,132,255,.55), 0 0 0 3px #0a84ff40;
      z-index: 15;
    }
    body.dark-mode .white-key { box-shadow: inset 0 0 0 1px #56616b, 0 4px 8px -3px rgba(0,0,0,.55); color: var(--text-dim); }
    body.dark-mode .white-key.active { color:#eef6ff; box-shadow: 0 0 0 1px #1787ff, 0 4px 16px -3px rgba(0,120,255,.7), 0 0 0 3px #0a84ff33; }

    .black-key {
      position: absolute;
      top: 0;
      transform: translateX(-50%);
      width: 48px;
      height: 60%;
      min-height: 100px;
  background: var(--black-key-bg);
  border: 1px solid var(--black-key-border);
      border-radius: 0 0 12px 12px;
      cursor: pointer;
      z-index: 25;
      display:flex;
      align-items: flex-start;
      justify-content: flex-start;
      padding: 6px 0 0 6px;
      font-size: .75rem;
      font-weight: 500;
      letter-spacing: .5px;
      color: #d4dde5;
      transition: background var(--transition), box-shadow var(--transition), transform var(--transition-fast), color var(--transition);
      box-shadow: inset 0 0 0 1px #303c46, 0 4px 10px -3px rgba(0,0,0,.55);
    }
    .black-key:active { transform: translateX(-50%) translateY(2px); }
    .black-key.active {
      background: var(--black-key-bg-active);
      color: #eef6ff;
      box-shadow: 0 0 0 1px #1787ff, 0 4px 16px -3px rgba(0,120,255,.7), 0 0 0 3px #0a84ff33;
    }
    body.dark-mode .black-key { box-shadow: inset 0 0 0 1px #37424c, 0 4px 10px -3px rgba(0,0,0,.7); color:#d4dde5; }
    body.dark-mode .black-key.active { color:#fff; }

    /* Piano vertical frequency grid */
    .note-grid-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background: var(--border);
      pointer-events: none;
      opacity: .65;
    }
    body.dark-mode .note-grid-line { opacity: .5; }
    .note-grid-line.root { background: var(--primary); opacity: .9; box-shadow: 0 0 0 1px var(--primary-glow); }
  /* Frequency labels for white key grid lines */
    .note-grid-label {
      position: absolute;
      top: 4px;
      font-size: 10px;
      font-weight: 500;
      color: var(--text-dim);
      background: var(--bg-alt); /* solid background */
      padding: 2px 4px 2px;
      border-radius: 4px;
      border: 1px solid var(--border);
      transform: translateX(-50%);
      pointer-events: none;
      line-height: 1;
      white-space: nowrap;
  z-index: 25; /* above timeline canvas dots */
      opacity: 1; /* ensure fully opaque */
    }
    body.dark-mode .note-grid-label { background: #1f252c; color: var(--text-dim); }
  /* (Labels removed as requested) */

    .helper-text { font-size: .82rem; color: var(--text-dim); line-height: 1.4; }
    a { color: var(--primary); text-decoration: none; } a:hover { text-decoration: underline; }

    .mode-indicator { font-size: .7rem; letter-spacing: 1.5px; font-weight: 600; opacity: .75; }
    .spacer { flex: 1 1 auto; }
    .toolbar { display: flex; gap:.6rem; align-items: center; }
    .toggle-dark { --btn-bg: var(--bg-alt); --btn-bg-hover:#e2e9f1; --btn-bg-active:#d4dde6; color: var(--text-dim); border-color: var(--border); }
    body.dark-mode .toggle-dark { --btn-bg:#232b33; --btn-bg-hover:#2c3540; --btn-bg-active:#1f2730; color:#d4dde5; }
    .toggle-dark[aria-pressed="true"] { box-shadow: 0 0 0 1px var(--primary), 0 0 0 4px #0a84ff33; color: var(--primary); }

    @media (max-width: 880px) {
      #app { padding-top: 1rem; }
      .display-grid { grid-template-columns: repeat(auto-fit,minmax(140px,1fr)); }
      .metric { min-height: 96px; }
      header { flex-wrap: wrap; gap: .75rem 1rem; }
    }
    @media (max-width: 560px) {
  :root { --white-key-width: 64px; }
    }

  /* (Removed recent pitch timeline styles) */
  </style>
</head>
<body>
  <header>
    <h1 aria-label="App title">Vocal Pitch Detector</h1>
    <div class="toolbar" role="toolbar" aria-label="Display controls">
      <button id="darkToggle" class="toggle-dark btn-secondary" type="button" aria-pressed="false" title="Toggle dark mode">🌙</button>
      <button id="start" type="button">Start</button>
      <button id="stop" type="button" disabled>Stop</button>
    </div>
  </header>
  <main id="app" tabindex="-1">
    <section class="panel" aria-label="Piano visualization" id="piano-wrapper">
      <div id="piano-scroll" aria-label="Scrollable piano" tabindex="0">
  <div id="piano-grid" aria-hidden="true"></div>
  <div id="piano" role="group" aria-label="Virtual piano keyboard"></div>
      </div>
    </section>
  <!-- Recent pitch timeline section removed -->
    <footer class="helper-text" style="text-align:center; margin-top:auto; padding-bottom:2rem;">
      <span>Pitch highlighting active. Start to detect; Stop to release microphone.</span>
    </footer>
  </main>
  <script>
    // Elements
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const pianoElem = document.getElementById('piano');
    const darkToggle = document.getElementById('darkToggle');
    let audioContext, analyser, dataArray, source, stream, listening = false, animationId;
    let currentActiveNote = '--';
  let lastRawFreq = null; // last detected (un-quantized) frequency
  let lastPianoDotEmit = 0; // throttle for piano overlay
  // Piano overlay history
  const PIANO_HISTORY_SECONDS = 5;
  const pianoHistory = []; // {note, freq, time}
  let pianoTimelineCanvas, pianoTimelineCtx;
  const noteXPositions = {}; // maps note name -> center x within grid

    // Dark mode persistence
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (localStorage.getItem('vpd-theme') === 'dark' || (!localStorage.getItem('vpd-theme') && prefersDark)) {
      document.body.classList.add('dark-mode');
      darkToggle.setAttribute('aria-pressed','true');
    }
    function updateThemeToggleLabel() {
      const isDark = document.body.classList.contains('dark-mode');
      // Show label indicating the target theme when clicked OR current theme? We'll show target for clarity
      darkToggle.textContent = isDark ? 'Light Mode' : 'Dark Mode';
      darkToggle.title = isDark ? 'Switch to light mode' : 'Switch to dark mode';
      darkToggle.setAttribute('aria-label', darkToggle.title);
    }
    updateThemeToggleLabel();
    darkToggle.addEventListener('click', () => {
      const isDark = document.body.classList.toggle('dark-mode');
      darkToggle.setAttribute('aria-pressed', String(isDark));
      localStorage.setItem('vpd-theme', isDark ? 'dark' : 'light');
      updateThemeToggleLabel();
  // Repaint piano grid to ensure colors (opacity) match theme
  drawPianoGridLines();
    });

    // Piano keys full 88-key range: A0 through C8
    const pianoNotes = [];
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']; // semitone names
    // MIDI numbers: A0 = 21, C8 = 108
    for (let midi = 21; midi <= 108; midi++) {
      const name = noteNames[midi % 12];
      const octave = Math.floor(midi / 12) - 1;
      pianoNotes.push(name + octave);
    }

    let whiteKeyElems = [];

    function renderPiano() {
      pianoElem.innerHTML = '';
      whiteKeyElems = [];
      for (let i = 0; i < pianoNotes.length; i++) {
        const note = pianoNotes[i];
        if (!note.includes('#')) {
          const key = document.createElement('div');
          key.className = 'white-key';
          key.dataset.note = note;
          key.innerHTML = `<span>${note}</span>`;
          pianoElem.appendChild(key);
          whiteKeyElems.push(key);
        }
      }
  // Ensure overlay canvas exists (removed on re-render because innerHTML cleared)
  ensurePianoTimelineCanvas();
      // Defer black key positioning until after whites have layout metrics
      requestAnimationFrame(positionBlackKeys);
  // After layout, draw vertical grid lines
  requestAnimationFrame(drawPianoGridLines);
      // After initial layout, compute and apply dynamic widths
      requestAnimationFrame(applyDynamicPianoWidth);
    }

    function applyDynamicPianoWidth() {
      const gridContainer = document.getElementById('piano-grid');
      if (!gridContainer || !whiteKeyElems.length) return;
      const style = getComputedStyle(document.documentElement);
      const keyW = parseFloat(style.getPropertyValue('--white-key-width'));
      const gap = parseFloat(style.getPropertyValue('--piano-key-gap'));
      const whiteCount = whiteKeyElems.length;
      // Total width = sum(white widths) + gaps between them
      const totalWidth = whiteCount * keyW + (whiteCount - 1) * gap;
      gridContainer.style.width = totalWidth + 'px';
      pianoElem.style.width = totalWidth + 'px';
      // Resize canvas to new width
      resizePianoTimelineCanvas();
      // Redraw grid lines with updated positions
      drawPianoGridLines();
    }

    function positionBlackKeys() {
      // Remove existing black keys
      pianoElem.querySelectorAll('.black-key').forEach(k => k.remove());
      let whiteIndex = 0;
      for (let i = 0; i < pianoNotes.length; i++) {
        const note = pianoNotes[i];
        if (!note.includes('#')) { whiteIndex++; continue; }
        const prevNote = pianoNotes[i - 1];
        if (!prevNote || prevNote.startsWith('E') || prevNote.startsWith('B')) continue; // skip positions where no black key
        const prevWhiteIdx = whiteIndex - 1;
        const nextWhiteIdx = whiteIndex;
        if (prevWhiteIdx < 0 || nextWhiteIdx >= whiteKeyElems.length) continue;
        const prevRect = whiteKeyElems[prevWhiteIdx].getBoundingClientRect();
        const nextRect = whiteKeyElems[nextWhiteIdx].getBoundingClientRect();
        const pianoRect = pianoElem.getBoundingClientRect();
        // Center between the right edge of previous and left edge of next white key
        const center = (prevRect.right + nextRect.left) / 2 - pianoRect.left;
        const blackKey = document.createElement('div');
        blackKey.className = 'black-key';
        blackKey.dataset.note = note;
        blackKey.style.left = center + 'px'; // transform:translateX(-50%) centers it
        blackKey.textContent = note;
        if (note === currentActiveNote) blackKey.classList.add('active');
        pianoElem.appendChild(blackKey);
      }
      // Update grid because black keys overlay may affect stacking context
      drawPianoGridLines();
    }

    // Utility: compute frequency from note name (reuse later too)
    function pianoNoteToFreq(note) {
      const m = note.match(/^([A-G]#?)(\d)$/);
      if (!m) return null;
      const name = m[1];
      const octave = parseInt(m[2],10);
      const A4 = 440;
      const noteIndex = noteNames.indexOf(name);
      const semitoneFromA4 = (octave - 4) * 12 + (noteIndex - 9); // where A is index 9
      return A4 * Math.pow(2, semitoneFromA4 / 12);
    }

    function drawPianoGridLines() {
      const gridContainer = document.getElementById('piano-grid');
      if (!gridContainer) return;
      gridContainer.querySelectorAll('.note-grid-line').forEach(el => el.remove());
      gridContainer.querySelectorAll('.note-grid-label').forEach(el => el.remove());
      if (!whiteKeyElems.length) return;
      const positions = {};
      const gridRect = gridContainer.getBoundingClientRect();
      // Use precise center based on DOM layout so margins/padding don't offset lines
      whiteKeyElems.forEach(k => {
        const r = k.getBoundingClientRect();
        const center = (r.left - gridRect.left) + r.width / 2;
        positions[k.dataset.note] = center;
      });
      pianoElem.querySelectorAll('.black-key').forEach(k => {
        const r = k.getBoundingClientRect();
        const center = (r.left - gridRect.left) + r.width / 2;
        positions[k.dataset.note] = center;
      });
      // Draw lines for all notes (white and black) centered precisely
      pianoNotes.forEach(note => {
        const x = positions[note];
        if (x == null) return;
        noteXPositions[note] = x; // persist for interpolation
        const line = document.createElement('div');
        line.className = 'note-grid-line' + (note.endsWith('C') ? ' root' : '');
        line.style.left = x + 'px';
        gridContainer.appendChild(line);
        // Add frequency label only for white keys
        if (!note.includes('#')) {
          const freq = pianoNoteToFreq(note);
          if (freq) {
            const label = document.createElement('div');
            label.className = 'note-grid-label';
            label.setAttribute('aria-hidden','true');
            label.style.left = x + 'px';
            label.textContent = freq.toFixed(2); // two decimals, no unit
            gridContainer.appendChild(label);
          }
        }
      });
    }

    // Recalculate on resize / orientation change (debounced)
    let resizeTimer;
    function handleResize() {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        // Only reposition (no need to rebuild whites) unless count changed
        positionBlackKeys();
  drawPianoGridLines();
  applyDynamicPianoWidth();
      }, 60);
    }
    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleResize);

    renderPiano();

    function highlightPiano(noteName) {
      const pianoScrollElem = document.getElementById('piano-scroll');
      currentActiveNote = noteName;
      let targetKey = null;
      Array.from(pianoElem.children).forEach(key => {
        if (key.dataset.note === noteName) {
          key.classList.add('active');
          targetKey = key;
        } else {
          key.classList.remove('active');
        }
      });
  // Keep grid lines above/below correct stacking by redrawing (cheap)
  drawPianoGridLines();
      if (targetKey && pianoScrollElem) {
        const keyLeft = targetKey.offsetLeft;
        const keyWidth = targetKey.offsetWidth;
        const scrollLeft = pianoScrollElem.scrollLeft;
        const scrollWidth = pianoScrollElem.offsetWidth;
        const targetScroll = keyLeft + keyWidth / 2 - scrollWidth / 2;
        if (keyLeft < scrollLeft || keyLeft + keyWidth > scrollLeft + scrollWidth) {
          pianoScrollElem.scrollTo({ left: targetScroll, behavior: 'smooth' });
        }
      }
  // Add a new event to history for timeline (actual note, not '--')
  // (Timeline event & auto-scroll removed)
    }

    // Note frequencies (A0 to C8)
    const notes = [
      'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'
    ];
    function freqToNote(frequency) {
      if (!frequency || frequency < 27.5 || frequency > 4186) return '--';
      const A4 = 440;
      const n = Math.round(12 * Math.log2(frequency / A4));
      // Ensure noteIndex is always positive
      const noteIndex = ((n + 9) % 12 + 12) % 12;
      const octave = 4 + Math.floor((n + 9) / 12);
      return notes[noteIndex] + octave;
    }

    // (Removed recent pitch timeline implementation)
    function noteToFrequency(note) { // still used for piano overlay
      const match = note.match(/^([A-G]#?)(\d)$/);
      if (!match) return null;
      const name = match[1];
      const octave = parseInt(match[2], 10);
      const A4 = 440;
      const noteIndex = notes.indexOf(name);
      const semitoneFromA4 = (octave - 4) * 12 + (noteIndex - 9);
      return A4 * Math.pow(2, semitoneFromA4 / 12);
    }
    const HISTORY_SECONDS = 5; // retain for piano overlay age calculations
    let dynamicEmissionInterval = 0.02; // fixed emission interval without timeline width adaptation

  /* ================= Piano Overlay History (bottom -> now, rising up) ================= */
    function ensurePianoTimelineCanvas() {
      const gridContainer = document.getElementById('piano-grid');
      if (!gridContainer) return;
      pianoTimelineCanvas = document.getElementById('piano-timeline-canvas');
      if (pianoTimelineCanvas && pianoTimelineCanvas.parentElement !== gridContainer) {
        // Move existing canvas from piano into grid
        pianoTimelineCanvas.remove();
        pianoTimelineCanvas = null;
      }
      if (!pianoTimelineCanvas) {
        pianoTimelineCanvas = document.createElement('canvas');
        pianoTimelineCanvas.id = 'piano-timeline-canvas';
        pianoTimelineCanvas.setAttribute('aria-hidden','true');
        gridContainer.appendChild(pianoTimelineCanvas);
      }
      pianoTimelineCtx = pianoTimelineCanvas.getContext('2d');
      resizePianoTimelineCanvas();
    }
    function resizePianoTimelineCanvas() {
      if (!pianoTimelineCanvas) return;
      const gridContainer = document.getElementById('piano-grid');
      if (!gridContainer) return;
      const rect = gridContainer.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      pianoTimelineCanvas.width = rect.width * dpr;
      pianoTimelineCanvas.height = rect.height * dpr;
      pianoTimelineCanvas.style.width = rect.width + 'px';
      pianoTimelineCanvas.style.height = rect.height + 'px';
      pianoTimelineCtx.setTransform(1,0,0,1,0,0);
      pianoTimelineCtx.scale(dpr,dpr);
    }
  window.addEventListener('resize', () => { resizePianoTimelineCanvas(); });
  ensurePianoTimelineCanvas();

    function prunePianoHistory(now) {
      const cutoff = now - PIANO_HISTORY_SECONDS;
      while (pianoHistory.length && pianoHistory[0].time < cutoff) pianoHistory.shift();
    }
    function drawPianoTimelineOverlay() {
      if (!pianoTimelineCanvas) return requestAnimationFrame(drawPianoTimelineOverlay);
      const now = performance.now()/1000;
      prunePianoHistory(now);
      const w = pianoTimelineCanvas.clientWidth;
      const h = pianoTimelineCanvas.clientHeight;
      pianoTimelineCtx.clearRect(0,0,w,h);
      // Ensure noteXPositions reflects latest layout (cheap: recompute only deltas if missing)
      // (We rely on drawPianoGridLines to populate; if empty, trigger it.)
      if (!Object.keys(noteXPositions).length) drawPianoGridLines();
      // Build ordered list of note positions for interpolation
      const orderedNotes = pianoNotes.filter(n => noteXPositions[n] != null);
      const orderedXs = orderedNotes.map(n => noteXPositions[n]);
      const orderedFreqs = orderedNotes.map(n => pianoNoteToFreq(n));
  const baseFreq = pianoNoteToFreq(pianoNotes[0]);
  const maxFreq = pianoNoteToFreq(pianoNotes[pianoNotes.length - 1]);
      function freqToX(f) {
        if (!f) return null;
        if (f <= baseFreq) return orderedXs[0] + 0.5;
        if (f >= maxFreq) return orderedXs[orderedXs.length-1] + 0.5;
        // Find surrounding semitone interval via binary search on orderedFreqs
        let lo = 0, hi = orderedFreqs.length - 1;
        while (lo <= hi) {
          const mid = (lo + hi) >> 1;
            if (orderedFreqs[mid] === f) return orderedXs[mid] + 0.5;
            if (orderedFreqs[mid] < f) lo = mid + 1; else hi = mid - 1;
        }
        const upper = lo; // first greater
        const lower = lo - 1;
        if (lower < 0 || upper >= orderedFreqs.length) return null;
        const f1 = orderedFreqs[lower], f2 = orderedFreqs[upper];
        const x1 = orderedXs[lower], x2 = orderedXs[upper];
  // Use logarithmic (pitch-space) interpolation so dot position reflects cents
  // distance between the two surrounding semitone centers, regardless of the
  // unequal *visual* spacing caused by white/black key geometry.
  // Each semitone is a constant ratio (2^(1/12)); so ratio of log2 values gives
  // fractional semitone without snapping.
  const ratio = (Math.log2(f / f1)) / (Math.log2(f2 / f1)); // 0..1
  return x1 + (x2 - x1) * ratio + 0.5; // add 0.5 for crisp alignment
      }
      // Visual settings
      const primary = getComputedStyle(document.body).getPropertyValue('--primary').trim();
      const glow = getComputedStyle(document.body).getPropertyValue('--primary-glow').trim();
      const maxAge = PIANO_HISTORY_SECONDS;
      if (!pianoHistory.length) {
        requestAnimationFrame(drawPianoTimelineOverlay);
        return;
      }
      pianoHistory.forEach(evt => {
        const age = now - evt.time;
        if (age < 0 || age > maxAge) return;
        const progress = age / maxAge;
        const x = freqToX(evt.freq) ?? noteXPositions[evt.note];
        if (x == null) return;
        const y = h - (progress * h);
  const radius = 2; // further reduced dot size
        const alpha = 1 - progress * 0.6; // gentler fade so dots stay more solid
        pianoTimelineCtx.globalAlpha = Math.max(0.45, alpha); // ensure reasonably solid appearance
        pianoTimelineCtx.fillStyle = primary; // solid color (no gradient glow)
        pianoTimelineCtx.beginPath();
        pianoTimelineCtx.arc(x, y, radius, 0, Math.PI * 2);
        pianoTimelineCtx.fill();
        pianoTimelineCtx.globalAlpha = 1;
      });
      requestAnimationFrame(drawPianoTimelineOverlay);
    }
    drawPianoTimelineOverlay();

    function autoCorrelate(buf, sampleRate) {
      // Simple autocorrelation
      let SIZE = buf.length;
      let rms = 0;
      for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
      rms = Math.sqrt(rms / SIZE);
      if (rms < 0.01) return null;
      let r1 = 0, r2 = SIZE - 1, thres = 0.2;
      for (let i = 0; i < SIZE / 2; i++) {
        if (Math.abs(buf[i]) < thres) { r1 = i; break; }
      }
      for (let i = 1; i < SIZE / 2; i++) {
        if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
      }
      buf = buf.slice(r1, r2);
      SIZE = buf.length;
      let c = new Array(SIZE).fill(0);
      for (let i = 0; i < SIZE; i++) {
        for (let j = 0; j < SIZE - i; j++) {
          c[i] = c[i] + buf[j] * buf[j + i];
        }
      }
      let d = 0; while (c[d] > c[d + 1]) d++;
      let maxval = -1, maxpos = -1;
      for (let i = d; i < SIZE; i++) {
        if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
      }
      let T0 = maxpos;
      return sampleRate / T0;
    }

    async function startListening() {
      if (listening) return;
      listening = true;
      startBtn.disabled = true;
      stopBtn.disabled = true; // temporarily while initializing
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        dataArray = new Float32Array(analyser.fftSize);
        source.connect(analyser);
        stopBtn.disabled = false;
        // Sticky note (debounce) variables
        const STICKY_MS = 100; // required consecutive ms for a note to become active
        let candidateNote = null;
        let candidateStartTime = 0;
        function update() {
          if (!listening) return;
          analyser.getFloatTimeDomainData(dataArray);
            const freq = autoCorrelate(dataArray, audioContext.sampleRate);
            lastRawFreq = freq || lastRawFreq; // retain last valid raw freq if current null
            const detectedNote = freqToNote(freq);
            const now = performance.now();

            // If detected note is already the active (highlighted) note, clear any candidate
            if (detectedNote === currentActiveNote) {
              candidateNote = null;
              candidateStartTime = 0;
            } else {
              // New or continuing candidate note path
              if (candidateNote !== detectedNote) {
                // Start tracking a new candidate note
                candidateNote = detectedNote;
                candidateStartTime = now;
              } else {
                // Same candidate persists – check duration
                if (now - candidateStartTime >= STICKY_MS) {
                  // Promote candidate to active
                  highlightPiano(candidateNote);
                  candidateNote = null;
                  candidateStartTime = 0;
                }
              }
            }
            // Continuous emission for piano overlay using RAW frequency (no snapping)
            const nowSec = now / 1000;
            if (freq && (nowSec - lastPianoDotEmit) >= dynamicEmissionInterval) {
              pianoHistory.push({ note: detectedNote, freq, time: nowSec });
              lastPianoDotEmit = nowSec;
            }
          animationId = requestAnimationFrame(update);
        }
        update();
      } catch (e) {
        console.error('Microphone access failed', e);
        listening = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }

    function stopListening() {
      if (!listening) return;
      listening = false;
      if (animationId) cancelAnimationFrame(animationId);
      if (audioContext) { audioContext.close(); audioContext = null; }
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      highlightPiano('--');
  // (Timeline cleared – no longer used)
  // Clear piano overlay
  pianoHistory.length = 0;
  lastPianoDotEmit = 0;
  if (pianoTimelineCtx) pianoTimelineCtx.clearRect(0,0,pianoTimelineCanvas.clientWidth,pianoTimelineCanvas.clientHeight);
      startBtn.disabled = false;
      stopBtn.disabled = true;
    }

    startBtn.addEventListener('click', startListening);
    stopBtn.addEventListener('click', stopListening);
  </script>
</body>
</html>
