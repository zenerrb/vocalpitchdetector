<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vocal Pitch Detector</title>
  <meta name="theme-color" content="#0a84ff" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f5f7fa;
      --bg-alt: #ffffff;
      --bg-elev: #ffffffcc;
      --text: #0f1419;
      --text-dim: #48525c;
      --primary: #0a84ff;
      --primary-glow: #7cc4ff;
      --border: #d8e1ea;
      --border-strong: #b3c2d1;
      --shadow: 0 4px 10px -2px rgba(0,0,0,.08), 0 2px 4px -1px rgba(0,0,0,.06);
      --radius-sm: 6px;
      --radius: 14px;
      --radius-lg: 22px;
      --focus: 0 0 0 3px #0a84ff40;
      --key-white: #ffffff;
      --key-white-edge: #c9d3dd;
      --key-black: #14181d;
      --highlight-white: linear-gradient(160deg,#b7ecff,#79c6ff 60%,#49a4ff);
      --highlight-black: linear-gradient(145deg,#27c3ff,#1787ff 60%,#0068ff);
      --danger: #d93030;
      --warning: #f7b537;
      --success: #12a150;
      --font-stack: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, 'Helvetica Neue', Arial, sans-serif;
      --transition-fast: 140ms cubic-bezier(.4,0,.2,1);
      --transition: 220ms cubic-bezier(.4,0,.2,1);
    }
    body.dark-mode {
      --bg: #0f1215;
      --bg-alt: #151a20;
      --bg-elev: #1c232bfa;
      --text: #eef2f6;
      --text-dim: #95a2b1;
      --border: #28313b;
      --border-strong: #3a4652;
      --key-white: #f3f6f9;
      --key-white-edge: #5a6673;
      --key-black: #070a0d;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: var(--font-stack);
      background: radial-gradient(circle at 30% 20%, #ffffff, var(--bg) 60%) fixed;
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      display: flex;
      flex-direction: column;
    }
    body.dark-mode { background: radial-gradient(circle at 70% 30%, #1e262e, var(--bg) 65%) fixed; }

    header {
      padding: clamp(0.75rem, 1.5vw, 1.1rem) clamp(1rem, 2vw, 2rem);
      display: flex;
      align-items: center;
      justify-content: space-between;
      backdrop-filter: blur(12px) saturate(140%);
      background: linear-gradient(90deg,var(--bg-elev),var(--bg-elev));
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 40;
    }
    h1 {
      margin: 0;
      font-size: clamp(1.2rem, 2.8vw, 1.85rem);
      font-weight: 600;
      letter-spacing: .5px;
      background: linear-gradient(120deg,var(--primary) 30%, var(--primary-glow));
  background-clip: text;
      -webkit-background-clip: text;
      color: transparent;
    }
    #app {
      width: 100%;
      max-width: 1180px;
      margin: 0 auto;
      padding: 1.4rem clamp(.75rem,2vw,1.75rem) 3rem;
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 2.2rem;
    }

    .panel {
      background: var(--bg-alt);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: clamp(1rem,2.8vw,1.85rem);
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }
    .panel:before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(140deg, var(--primary)10%, transparent 45%, transparent 55%, var(--primary-glow) 90%);
      opacity: .07;
      pointer-events: none;
    }

    .display-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit,minmax(180px,1fr));
      gap: 1.25rem;
      align-items: stretch;
    }
    .metric {
      background: linear-gradient(180deg,var(--bg-alt), var(--bg) 120%);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: .9rem 1.1rem 1rem;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: .35rem;
      min-height: 112px;
    }
    .metric h2 {
      font-size: .8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.4px;
      margin: 0;
      color: var(--text-dim);
    }
    .metric .value {
      font-size: clamp(1.4rem,3.8vw,2.8rem);
      font-weight: 600;
      line-height: 1.05;
      letter-spacing: .5px;
      font-variant-numeric: tabular-nums;
      word-break: break-word;
    }
    .metric.small .value { font-size: clamp(1rem,2.5vw,1.45rem); }

    .actions { display:flex; flex-wrap:wrap; gap:.75rem; }
    button, .btn {
      --btn-bg: var(--primary);
      --btn-bg-hover: #006fe6;
      --btn-bg-active: #005bbd;
      --btn-text: #fff;
      font: inherit;
      font-weight: 600;
      padding: .8rem 1.3rem .85rem;
      border-radius: var(--radius-sm);
      background: var(--btn-bg);
      color: var(--btn-text);
      border: 1px solid var(--btn-bg);
      cursor: pointer;
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: .55rem;
      line-height: 1.1;
      letter-spacing: .3px;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
      box-shadow: 0 1px 2px rgba(0,0,0,.15), 0 4px 10px -4px rgba(0,0,0,.25);
      will-change: transform;
      text-decoration: none;
    }
    button:focus-visible { outline: none; box-shadow: var(--focus); }
    button:hover { background: var(--btn-bg-hover); }
    button:active { background: var(--btn-bg-active); transform: translateY(1px); }
    button:disabled { opacity: .55; cursor: not-allowed; filter: grayscale(.3); }
    .btn-secondary { --btn-bg: var(--bg-alt); --btn-bg-hover: #e2e8f0; --btn-bg-active:#d5dee8; --btn-text: var(--text); border-color: var(--border-strong); }
    body.dark-mode .btn-secondary { --btn-bg: #232b33; --btn-bg-hover:#2c3540; --btn-bg-active:#1d252d; }

    /* Piano */
    #piano-wrapper { position: relative; }
    #piano-scroll {
      width: 100%;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding: 1rem .4rem 1.6rem;
      margin: 0 auto;
      border-radius: var(--radius);
      background: linear-gradient(180deg,var(--bg-alt), var(--bg));
      border: 1px solid var(--border);
      box-shadow: inset 0 0 0 1px var(--border), var(--shadow);
    }
    #piano-scroll::-webkit-scrollbar { height: 14px; }
    #piano-scroll::-webkit-scrollbar-track { background: transparent; }
    #piano-scroll::-webkit-scrollbar-thumb { background: #b8c6d4; border-radius: 100px; border: 3px solid var(--bg-alt); }
    body.dark-mode #piano-scroll::-webkit-scrollbar-thumb { background:#465563; border-color: #1d252d; }

    #piano {
      position: relative;
      display: flex;
      flex-direction: row;
      height: clamp(180px, 30vh, 240px);
      min-height: 140px;
      width: 2320px;
      padding: 0 4px 6px;
      user-select: none;
    }
    .white-key {
      position: relative;
      display: inline-flex;
      justify-content: center;
      align-items: flex-end;
      width: 80px;
      flex: 0 0 80px;
      height: 100%;
      background: linear-gradient(180deg,var(--key-white) 0%, #e9eef3 96%);
      border: 1px solid var(--key-white-edge);
      border-top: 1px solid #f8fafc;
      border-radius: 0 0 18px 18px;
      margin: 0 1px;
      font-size: .85rem;
      font-weight: 500;
      color: var(--text-dim);
      letter-spacing: .5px;
      cursor: pointer;
      transition: background var(--transition), color var(--transition), box-shadow var(--transition), transform var(--transition-fast);
      box-shadow: inset 0 0 0 1px #fff, 0 4px 8px -3px rgba(0,0,0,.25);
    }
    .white-key span { position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); pointer-events: none; }
    .white-key:active { transform: translateY(2px); }
    .white-key.active {
      background: var(--highlight-white);
      color: #06314d;
      box-shadow: 0 0 0 1px #117ebf, 0 4px 14px -3px rgba(0,132,255,.55), 0 0 0 3px #0a84ff40;
      z-index: 15;
    }

    .black-key {
      position: absolute;
      top: 0;
      transform: translateX(-50%);
      width: 48px;
      height: 60%;
      min-height: 100px;
      background: linear-gradient(175deg,#242b32,#0d1114 80%);
      border: 1px solid #0b0f12;
      border-radius: 0 0 12px 12px;
      cursor: pointer;
      z-index: 25;
      display:flex;
      align-items: flex-start;
      justify-content: flex-start;
      padding: 6px 0 0 6px;
      font-size: .75rem;
      font-weight: 500;
      letter-spacing: .5px;
      color: #d4dde5;
      transition: background var(--transition), box-shadow var(--transition), transform var(--transition-fast), color var(--transition);
      box-shadow: inset 0 0 0 1px #303c46, 0 4px 10px -3px rgba(0,0,0,.55);
    }
    .black-key:active { transform: translateX(-50%) translateY(2px); }
    .black-key.active {
      background: var(--highlight-black);
      color: #eef6ff;
      box-shadow: 0 0 0 1px #1787ff, 0 4px 16px -3px rgba(0,120,255,.7), 0 0 0 3px #0a84ff33;
    }

    .helper-text { font-size: .82rem; color: var(--text-dim); line-height: 1.4; }
    a { color: var(--primary); text-decoration: none; } a:hover { text-decoration: underline; }

    .mode-indicator { font-size: .7rem; letter-spacing: 1.5px; font-weight: 600; opacity: .75; }
    .spacer { flex: 1 1 auto; }
    .toolbar { display: flex; gap:.6rem; align-items: center; }
    .toggle-dark { --btn-bg: var(--bg-alt); --btn-bg-hover:#e2e9f1; --btn-bg-active:#d4dde6; color: var(--text-dim); border-color: var(--border); }
    body.dark-mode .toggle-dark { --btn-bg:#232b33; --btn-bg-hover:#2c3540; --btn-bg-active:#1f2730; color:#d4dde5; }
    .toggle-dark[aria-pressed="true"] { box-shadow: 0 0 0 1px var(--primary), 0 0 0 4px #0a84ff33; color: var(--primary); }

    @media (max-width: 880px) {
      #app { padding-top: 1rem; }
      .display-grid { grid-template-columns: repeat(auto-fit,minmax(140px,1fr)); }
      .metric { min-height: 96px; }
      header { flex-wrap: wrap; gap: .75rem 1rem; }
      #piano { width: 2000px; }
    }
    @media (max-width: 560px) {
      #piano { width: 1700px; }
      .white-key { width: 64px; flex: 0 0 64px; }
    }

    /* Timeline (5s history) */
    #timeline-wrapper { position: relative; }
    #timeline-container {
      position: relative;
      height: clamp(320px,46vh,520px);
      width: 100%;
      overflow-y: auto;
      overscroll-behavior: contain;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(180deg,var(--bg-alt),var(--bg) 140%);
    }
    #noteTimeline { width: 100%; height: 100%; display: block; user-select: none; touch-action: none; }
  /* Vertical scrollbar styling to match piano horizontal */
  #timeline-container::-webkit-scrollbar { width: 14px; }
  #timeline-container::-webkit-scrollbar-track { background: transparent; }
  #timeline-container::-webkit-scrollbar-thumb { background: #b8c6d4; border-radius: 100px; border: 3px solid var(--bg-alt); }
  body.dark-mode #timeline-container::-webkit-scrollbar-thumb { background:#465563; border-color: #1d252d; }
  </style>
</head>
<body>
  <header>
    <h1 aria-label="App title">Vocal Pitch Detector</h1>
    <div class="toolbar" role="toolbar" aria-label="Display controls">
      <button id="darkToggle" class="toggle-dark btn-secondary" type="button" aria-pressed="false" title="Toggle dark mode">ðŸŒ™</button>
      <button id="start" type="button">Start</button>
      <button id="stop" type="button" disabled>Stop</button>
    </div>
  </header>
  <main id="app" tabindex="-1">
    <section class="panel" aria-label="Piano visualization" id="piano-wrapper">
      <div id="piano-scroll" aria-label="Scrollable piano" tabindex="0">
        <div id="piano" role="group" aria-label="Virtual piano keyboard"></div>
      </div>
    </section>
    <section class="panel" aria-label="Recent pitch timeline" id="timeline-wrapper">
      <div id="timeline-container">
        <canvas id="noteTimeline" aria-label="5 second note history visualization"></canvas>
      </div>
    </section>
    <footer class="helper-text" style="text-align:center; margin-top:auto; padding-bottom:2rem;">
      <span>Pitch highlighting active. Start to detect; Stop to release microphone.</span>
    </footer>
  </main>
  <script>
    // Elements
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const pianoElem = document.getElementById('piano');
    const darkToggle = document.getElementById('darkToggle');
    let audioContext, analyser, dataArray, source, stream, listening = false, animationId;
    let currentActiveNote = '--';
  let lastDotEmit = 0; // seconds timestamp for timeline dot throttling
  let lastRawFreq = null; // last detected (un-quantized) frequency

    // Dark mode persistence
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (localStorage.getItem('vpd-theme') === 'dark' || (!localStorage.getItem('vpd-theme') && prefersDark)) {
      document.body.classList.add('dark-mode');
      darkToggle.setAttribute('aria-pressed','true');
    }
    function updateThemeToggleLabel() {
      const isDark = document.body.classList.contains('dark-mode');
      // Show label indicating the target theme when clicked OR current theme? We'll show target for clarity
      darkToggle.textContent = isDark ? 'Light Mode' : 'Dark Mode';
      darkToggle.title = isDark ? 'Switch to light mode' : 'Switch to dark mode';
      darkToggle.setAttribute('aria-label', darkToggle.title);
    }
    updateThemeToggleLabel();
    darkToggle.addEventListener('click', () => {
      const isDark = document.body.classList.toggle('dark-mode');
      darkToggle.setAttribute('aria-pressed', String(isDark));
      localStorage.setItem('vpd-theme', isDark ? 'dark' : 'light');
      updateThemeToggleLabel();
    });

    // Piano keys from C2 to C6
    const pianoNotes = [];
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    let reachedEnd = false;
    for (let octave = 2; octave <= 6 && !reachedEnd; octave++) {
      for (let i = 0; i < noteNames.length && !reachedEnd; i++) {
        const note = noteNames[i] + octave;
        pianoNotes.push(note);
        if (note === 'C6') reachedEnd = true;
      }
    }

    let whiteKeyElems = [];

    function renderPiano() {
      pianoElem.innerHTML = '';
      whiteKeyElems = [];
      for (let i = 0; i < pianoNotes.length; i++) {
        const note = pianoNotes[i];
        if (!note.includes('#')) {
          const key = document.createElement('div');
          key.className = 'white-key';
          key.dataset.note = note;
          key.innerHTML = `<span>${note}</span>`;
          pianoElem.appendChild(key);
          whiteKeyElems.push(key);
        }
      }
      // Defer black key positioning until after whites have layout metrics
      requestAnimationFrame(positionBlackKeys);
    }

    function positionBlackKeys() {
      // Remove existing black keys
      pianoElem.querySelectorAll('.black-key').forEach(k => k.remove());
      let whiteIndex = 0;
      for (let i = 0; i < pianoNotes.length; i++) {
        const note = pianoNotes[i];
        if (!note.includes('#')) { whiteIndex++; continue; }
        const prevNote = pianoNotes[i - 1];
        if (!prevNote || prevNote.startsWith('E') || prevNote.startsWith('B')) continue; // skip positions where no black key
        const prevWhiteIdx = whiteIndex - 1;
        const nextWhiteIdx = whiteIndex;
        if (prevWhiteIdx < 0 || nextWhiteIdx >= whiteKeyElems.length) continue;
        const prevRect = whiteKeyElems[prevWhiteIdx].getBoundingClientRect();
        const nextRect = whiteKeyElems[nextWhiteIdx].getBoundingClientRect();
        const pianoRect = pianoElem.getBoundingClientRect();
        // Center between the right edge of previous and left edge of next white key
        const center = (prevRect.right + nextRect.left) / 2 - pianoRect.left;
        const blackKey = document.createElement('div');
        blackKey.className = 'black-key';
        blackKey.dataset.note = note;
        blackKey.style.left = center + 'px'; // transform:translateX(-50%) centers it
        blackKey.textContent = note;
        if (note === currentActiveNote) blackKey.classList.add('active');
        pianoElem.appendChild(blackKey);
      }
    }

    // Recalculate on resize / orientation change (debounced)
    let resizeTimer;
    function handleResize() {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        // Only reposition (no need to rebuild whites) unless count changed
        positionBlackKeys();
      }, 60);
    }
    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleResize);

    renderPiano();

    function highlightPiano(noteName) {
      const pianoScrollElem = document.getElementById('piano-scroll');
      currentActiveNote = noteName;
      let targetKey = null;
      Array.from(pianoElem.children).forEach(key => {
        if (key.dataset.note === noteName) {
          key.classList.add('active');
          targetKey = key;
        } else {
          key.classList.remove('active');
        }
      });
      if (targetKey && pianoScrollElem) {
        const keyLeft = targetKey.offsetLeft;
        const keyWidth = targetKey.offsetWidth;
        const scrollLeft = pianoScrollElem.scrollLeft;
        const scrollWidth = pianoScrollElem.offsetWidth;
        const targetScroll = keyLeft + keyWidth / 2 - scrollWidth / 2;
        if (keyLeft < scrollLeft || keyLeft + keyWidth > scrollLeft + scrollWidth) {
          pianoScrollElem.scrollTo({ left: targetScroll, behavior: 'smooth' });
        }
      }
  // Add a new event to history for timeline (actual note, not '--')
  if (noteName && noteName !== '--') pushNoteEvent(noteName);
      // Auto-scroll timeline vertically to keep current note in view
      if (noteName && noteName !== '--') {
        requestAnimationFrame(() => scrollTimelineToNote(noteName));
      }
    }

    // Note frequencies (A0 to C8)
    const notes = [
      'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'
    ];
    function freqToNote(frequency) {
      if (!frequency || frequency < 27.5 || frequency > 4186) return '--';
      const A4 = 440;
      const n = Math.round(12 * Math.log2(frequency / A4));
      // Ensure noteIndex is always positive
      const noteIndex = ((n + 9) % 12 + 12) % 12;
      const octave = 4 + Math.floor((n + 9) / 12);
      return notes[noteIndex] + octave;
    }

    /* ================= Timeline (5 second scrolling note history) ================= */
    const timelineCanvas = document.getElementById('noteTimeline');
    const timelineCtx = timelineCanvas.getContext('2d');
    const HISTORY_SECONDS = 5;
    const timelineNotes = []; // Will hold all note names (C2..C6) vertically
    for (let octave = 2; octave <= 6; octave++) {
      for (const n of notes) {
        const note = n + octave;
        timelineNotes.push(note);
        if (note === 'C6') break; // stop at C6 inclusive
      }
      if (timelineNotes[timelineNotes.length - 1] === 'C6') break;
    }
    // Precompute frequencies for each timeline note for precise vertical scaling
    function noteToFrequency(note) {
      const match = note.match(/^([A-G]#?)(\d)$/);
      if (!match) return null;
      const name = match[1];
      const octave = parseInt(match[2], 10);
      const A4 = 440;
      const noteIndex = notes.indexOf(name);
      const semitoneFromA4 = (octave - 4) * 12 + (noteIndex - 9); // A4 index 9
      return A4 * Math.pow(2, semitoneFromA4 / 12);
    }
  // note frequencies retained for potential future precise mapping (currently row-based)
  const noteFreqs = timelineNotes.map(noteToFrequency);

    function scrollTimelineToNote(note) {
      const container = document.getElementById('timeline-container');
      if (!container) return;
      const idx = timelineNotes.indexOf(note);
      if (idx === -1) return;
  const totalHeight = timelineNotes.length * TIMELINE_CONFIG.rowHeight;
  // Map note's frequency via same log mapping used in draw
  const noteFreq = noteToFrequency(note);
  const minDisplayFreq = noteToFrequency('C2');
  const maxDisplayFreq = noteToFrequency('C6');
  const logMin = Math.log(minDisplayFreq);
  const logMax = Math.log(maxDisplayFreq);
  const ratio = (Math.log(noteFreq) - logMin) / (logMax - logMin);
  const y = totalHeight - ratio * totalHeight; // same as freqToY
  const targetScrollTop = Math.min(Math.max(y - container.clientHeight / 2, 0), totalHeight - container.clientHeight);
      // Only scroll if outside comfortable viewport bounds (e.g., 15% padding)
      const padding = container.clientHeight * 0.15;
  if (y < container.scrollTop + padding || y > container.scrollTop + container.clientHeight - padding) {
        container.scrollTo({ top: targetScrollTop, behavior: 'smooth' });
      }
    }

    let noteEvents = []; // {note, time, freq}

    function pushNoteEvent(note, rawFreqOverride) {
      const now = performance.now() / 1000; // seconds
      // Use provided raw frequency if valid; else derive from note (center frequency)
      let freq = (rawFreqOverride && rawFreqOverride > 0) ? rawFreqOverride : noteToFrequency(note);
      if (!freq) return;
      // Clamp frequency range to timeline range
      const minDisplay = noteToFrequency('C2');
      const maxDisplay = noteToFrequency('C6');
      if (freq < minDisplay || freq > maxDisplay) return;
      noteEvents.push({ note, time: now, freq });
      pruneEvents(now);
    }
    function pruneEvents(nowSec) {
      const cutoff = nowSec - HISTORY_SECONDS;
      // Keep events newer than cutoff
      while (noteEvents.length && noteEvents[0].time < cutoff) noteEvents.shift();
    }

    // Timeline sizing config
    const TIMELINE_CONFIG = {
      rowHeight: 48,          // px per note row (increase for "wider" bands)
      dotRadius: 5,           // radius of dots (even smaller)
      emissionInterval: 0.025 // seconds between dots (~40/sec)
    };

    function resizeTimeline() {
      const container = document.getElementById('timeline-container');
      const rect = container.getBoundingClientRect();
      // Give ample vertical resolution for frequency lines: proportional to note count * rowHeight
      const totalHeight = timelineNotes.length * TIMELINE_CONFIG.rowHeight;
      timelineCanvas.style.height = totalHeight + 'px';
      const dpr = window.devicePixelRatio || 1;
      timelineCanvas.width = rect.width * dpr;
      timelineCanvas.height = totalHeight * dpr;
      timelineCtx.setTransform(1,0,0,1,0,0);
      timelineCtx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resizeTimeline);
    resizeTimeline();

    function drawTimeline() {
      const now = performance.now() / 1000;
      pruneEvents(now);
  const w = timelineCanvas.clientWidth;
  const h = timelineCanvas.clientHeight;
  timelineCtx.clearRect(0, 0, w, h);
      // Background gradient subtle
      const bgGrad = timelineCtx.createLinearGradient(0,0,0,h);
      bgGrad.addColorStop(0, getComputedStyle(document.body).getPropertyValue('--bg-alt').trim());
      bgGrad.addColorStop(1, getComputedStyle(document.body).getPropertyValue('--bg').trim());
      timelineCtx.fillStyle = bgGrad;
      timelineCtx.fillRect(0,0,w,h);

      // Draw horizontal grid lines for each note (optional subset to reduce clutter)
      timelineCtx.font = '11px "Inter", system-ui';
      timelineCtx.textBaseline = 'middle';
      const lineColor = getComputedStyle(document.body).getPropertyValue('--border').trim();
      const textColor = getComputedStyle(document.body).getPropertyValue('--text-dim').trim();
      timelineCtx.strokeStyle = lineColor;
      timelineCtx.lineWidth = 1;

      // Continuous frequency scale using log mapping between C2 and C6
      const minDisplayFreq = noteToFrequency('C2');
      const maxDisplayFreq = noteToFrequency('C6');
      const logMin = Math.log(minDisplayFreq);
      const logMax = Math.log(maxDisplayFreq);
      function freqToY(f) {
        const clamped = Math.min(Math.max(f, minDisplayFreq), maxDisplayFreq);
        const ratio = (Math.log(clamped) - logMin) / (logMax - logMin);
        return h - ratio * h; // low freq bottom, high top
      }
      const rowHeight = TIMELINE_CONFIG.rowHeight;

      timelineCtx.beginPath();
      // Draw horizontal reference lines for each note position
      timelineNotes.forEach(note => {
        const f = noteToFrequency(note);
        const y = freqToY(f);
        timelineCtx.strokeStyle = lineColor;
        timelineCtx.lineWidth = 1;
        timelineCtx.beginPath();
        timelineCtx.moveTo(0, y + 0.5);
        timelineCtx.lineTo(w, y + 0.5);
        timelineCtx.stroke();
        timelineCtx.fillStyle = textColor;
        timelineCtx.fillText(note, 6, y - 8); // slightly above line
      });

      // Time axis: right = now, left = now - HISTORY_SECONDS
      const primaryColor = getComputedStyle(document.body).getPropertyValue('--primary').trim();
      const glow = getComputedStyle(document.body).getPropertyValue('--primary-glow').trim();
      // Draw events as circles that move left over time
      noteEvents.forEach(evt => {
        const age = now - evt.time; // 0..HISTORY_SECONDS
        if (age < 0 || age > HISTORY_SECONDS) return;
        const x = w - (age / HISTORY_SECONDS) * w;
        const y = freqToY(evt.freq);
        const fade = 1 - age / HISTORY_SECONDS; // fade out
        const radius = TIMELINE_CONFIG.dotRadius; // bigger dots
        const grd = timelineCtx.createRadialGradient(x,y,0,x,y,radius);
        grd.addColorStop(0, primaryColor + '');
        grd.addColorStop(1, glow + '55');
        timelineCtx.globalAlpha = Math.max(.2, fade);
        timelineCtx.fillStyle = grd;
        timelineCtx.beginPath();
        timelineCtx.arc(x, y, radius, 0, Math.PI*2);
        timelineCtx.fill();
        timelineCtx.globalAlpha = 1;
      });

  // (Removed current time vertical line per request)

      requestAnimationFrame(drawTimeline);
    }
    drawTimeline();

    function autoCorrelate(buf, sampleRate) {
      // Simple autocorrelation
      let SIZE = buf.length;
      let rms = 0;
      for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
      rms = Math.sqrt(rms / SIZE);
      if (rms < 0.01) return null;
      let r1 = 0, r2 = SIZE - 1, thres = 0.2;
      for (let i = 0; i < SIZE / 2; i++) {
        if (Math.abs(buf[i]) < thres) { r1 = i; break; }
      }
      for (let i = 1; i < SIZE / 2; i++) {
        if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
      }
      buf = buf.slice(r1, r2);
      SIZE = buf.length;
      let c = new Array(SIZE).fill(0);
      for (let i = 0; i < SIZE; i++) {
        for (let j = 0; j < SIZE - i; j++) {
          c[i] = c[i] + buf[j] * buf[j + i];
        }
      }
      let d = 0; while (c[d] > c[d + 1]) d++;
      let maxval = -1, maxpos = -1;
      for (let i = d; i < SIZE; i++) {
        if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
      }
      let T0 = maxpos;
      return sampleRate / T0;
    }

    async function startListening() {
      if (listening) return;
      listening = true;
      startBtn.disabled = true;
      stopBtn.disabled = true; // temporarily while initializing
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        dataArray = new Float32Array(analyser.fftSize);
        source.connect(analyser);
        stopBtn.disabled = false;
        // Sticky note (debounce) variables
        const STICKY_MS = 100; // required consecutive ms for a note to become active
        let candidateNote = null;
        let candidateStartTime = 0;
        function update() {
          if (!listening) return;
          analyser.getFloatTimeDomainData(dataArray);
            const freq = autoCorrelate(dataArray, audioContext.sampleRate);
            lastRawFreq = freq || lastRawFreq; // retain last valid raw freq if current null
            const detectedNote = freqToNote(freq);
            const now = performance.now();

            // If detected note is already the active (highlighted) note, clear any candidate
            if (detectedNote === currentActiveNote) {
              candidateNote = null;
              candidateStartTime = 0;
            } else {
              // New or continuing candidate note path
              if (candidateNote !== detectedNote) {
                // Start tracking a new candidate note
                candidateNote = detectedNote;
                candidateStartTime = now;
              } else {
                // Same candidate persists â€“ check duration
                if (now - candidateStartTime >= STICKY_MS) {
                  // Promote candidate to active
                  highlightPiano(candidateNote);
                  candidateNote = null;
                  candidateStartTime = 0;
                }
              }
            }
            // Continuous emission of timeline dots for sustained active note
            const nowSec = now / 1000;
            if (currentActiveNote !== '--' && (nowSec - lastDotEmit) >= TIMELINE_CONFIG.emissionInterval) { // adjustable rate
              pushNoteEvent(currentActiveNote, lastRawFreq);
              lastDotEmit = nowSec;
            }
          animationId = requestAnimationFrame(update);
        }
        update();
      } catch (e) {
        console.error('Microphone access failed', e);
        listening = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }

    function stopListening() {
      if (!listening) return;
      listening = false;
      if (animationId) cancelAnimationFrame(animationId);
      if (audioContext) { audioContext.close(); audioContext = null; }
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      highlightPiano('--');
  // Clear timeline events when stopping
  noteEvents.length = 0;
  lastDotEmit = 0;
      startBtn.disabled = false;
      stopBtn.disabled = true;
    }

    startBtn.addEventListener('click', startListening);
    stopBtn.addEventListener('click', stopListening);
  </script>
</body>
</html>
